# ch6. 데이터베이스 연동(1) - 이론

### 1-1. ORM(Object Relation Mapping)이란

![[https://djcho.github.io/springboot/spring-boot-chapter6-2/](https://djcho.github.io/springboot/spring-boot-chapter6-2/)](ch6%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A9%E1%86%BC(1)%20-%20%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB%20b576cf7cbafb409e8505820cc4a19d1e/Untitled.png)

[https://djcho.github.io/springboot/spring-boot-chapter6-2/](https://djcho.github.io/springboot/spring-boot-chapter6-2/)

- 객체 지향 언어(Java)로 구현된 객체 - RDB(Relational Database)의 테이블 자동 매핑하는 방법
- Java 클래스와 테이블 간 불일치 해결
- 쿼리문이 아닌 코드로 데이터 조작 가능

### 1**-2. ORM의 장점**

- 데이터베이스 쿼리를 객체지향적으로 조작 가능
    - 코드의 가독성 ↑
    - 쿼리문 작성양 감소 → 개발 비용 감소
- 재사용 및 유지보수 편리
    - ORM을 통해 매핑된 객체는 모두 독립적으로 작성 → 재사용 편리
    - 객체가 각 클래스로 구분 → 유지보수 편리
- 데이터베이스에 대한 종속성 감소
    - 데이터베이스 교체 → 리스크↓
    - ORM통해 생성된 SQL문은 객체 기반으로 데이터베이스 테이블 관리 → 데이터베이스에 종속X

### 1**-3. ORM의 단점**

- ORM만으로 온전한 서비스 구현 한계
    - 복잡한 서비스의 경우, 직접 쿼리 작성하는 게 적합
    - 속도 저하 등 성능문제 발생 가능
- 애플리케이션의 객체 관점과 데이터베이스 관계 관점의 불일치
    - 세분성: ORM 자동 설계 방법에 따라 데이터베이스 테이블 수 ≠ 애플리케이션의 엔티티 클래스 수
    (클래스가 테이블 수보다 많아질 수 있음)
    - 상속성: RDBMS는 상속 개념X
    - 식별성: RDBMS는 기본키로 동일성 정의, but 자바는 두 객체의 값이 같아도 다르다고 판단 가능
    - 연관성
        
        
        | 객체지향 언어(Java) | RDBMS |
        | --- | --- |
        | 객체를 참조함으로써 연관성 표현 | 외래키 삽입으로 연관성 표현 |
        | 객체 참조시 방향성이 존재 | 외래키 삽입시, 양방향의 관계 |
    - 탐색
        - 자바와 RDBMS는 어떤 값(객체)에 접근하는 방식이 다르다.
        - 자바: 특정값에 접근하기 위해 연결 수단(객체 참조 등) 활용
        (ex: member.getOrganization().getAddress())
        - RDBMS: 쿼리 최소화, Join을 통해 여러 테이블 로드 & 값 추출하는 접근방식 활용

### 2. JPA(Java Persistence API)

- 자바 진영의 ORM 기술 표준으로 채택된 인터페이스 모음(JPA **⊂** ORM)
- 동작 메커니즘을 정리한 표준 명세서일뿐 동작하는 무언가는 아니다!!
- 개발자가 직접 JDBC 구현 → 개발자가 SQL에 의존하는 문제를 해결하고자 활용
- JDBC ⊂ JPA : 개발자 대신 적절한 SQL 생성, 데이터베이스 조작 - 객체 자동 매핑
- JPA기반의 구현체
    
    ![Untitled](ch6%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A9%E1%86%BC(1)%20-%20%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB%20b576cf7cbafb409e8505820cc4a19d1e/Untitled%201.png)
    

### 3. Hibernate

![[https://velog.io/@tkrhdrhkdduf/데이터베이스-연동](https://velog.io/@tkrhdrhkdduf/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%97%B0%EB%8F%99)](ch6%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A9%E1%86%BC(1)%20-%20%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB%20b576cf7cbafb409e8505820cc4a19d1e/Untitled%202.png)

[https://velog.io/@tkrhdrhkdduf/데이터베이스-연동](https://velog.io/@tkrhdrhkdduf/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%97%B0%EB%8F%99)

- 자바의 ORM 프레임워크이자 JPA 구현체 중 하나(Hibernate **⊂** JPA)
- Spring Data JPA
    - JPA를 편리하게 사용할 수 있도록 지원하는 스프링 하위 프로젝트 중 하나
    - CRUD 처리에 필요한 인터페이스 제공
    - Hibernate의 엔티티 매니저를 직접 다룸(x) 리포지토리 정의해 사용(o)
    - 스프링이 적합한 쿼리를 동적으로 생성하여 데이터베이스 조작

### 4. 영속성 컨텍스트(Persistence Context)

![[https://velog.io/@tkrhdrhkdduf/데이터베이스-연동](https://velog.io/@tkrhdrhkdduf/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%97%B0%EB%8F%99)](ch6%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A9%E1%86%BC(1)%20-%20%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB%20b576cf7cbafb409e8505820cc4a19d1e/Untitled%203.png)

[https://velog.io/@tkrhdrhkdduf/데이터베이스-연동](https://velog.io/@tkrhdrhkdduf/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%97%B0%EB%8F%99)

- 애플리케이션(엔티티) - 데이터베이스(레코드)간 괴리 해소 & 객체 보관 기능
- 엔티티 객체 → 영속성 컨텍스트 → 영속 객체로 전환 → 엔티티 객체의 매핑 정보를 데이터 베이스에 반영
- 영속 객체 : 영속성 컨텍스트에 들어와서 JPA 관리 대상이 되는 시점의 엔티티 객체
- 세션 단위의 생명주기
    - 데이터베이스에 접근하기 위한 세션 생성 → 영속성 컨텍스트 생성
    - 세션 종료 → 영속성 컨텍스트 종료
    - 엔티티 매니저는 영속성 컨텍스트에 접근하기 위한 수단
    

### 5. 엔티티 매니저

- 엔티티 관리하는 객체 - 데이터베이스에 접근해서 CRUD 작업 수행
- Spring Data JPA 사용시, 리포지토리에 주입한 엔티티 매니저를 사용해서 데이터베이스 접근
- 엔티티 매니저 팩토리 → 엔티티 매니저 생성
- 엔티티 매니저 팩토리
    - 데이터 베이스에 대응하는 객체
    - 스프링 부트 내 자동 설정 기능 O → application.properites에서 작성한 최소한의 설정으로 동작
    - 그러나 Hibernate에서는 persistence.xml(설정 파일)구성하고 사용해야 하는 객체
    - 어플리케이션당 하나만 생성 - 모든 엔티티가 팩토리 공유해서 사용
- 엔티티 생명주기
    - 비영속: 영속성 컨텍스트에 추가되지 않은 엔티티 객체 상태
    - 영속: 영속성 컨텍스트에 의해 엔티티 객체가 관리되는 상태
    - 준영속: 영속성 컨텍스트에 의해 관리되던 엔티티 객체가 컨텍스트와 분리된 상태
    - 삭제: 데이터베이스에서 레코드를 삭제하기 위해 영속성 컨텍스트에 삭제 요청한 상태

### 6. ORM, JPA, Hibernate, 영속성 컨텍스트, 엔티티 매니저 관계성

- ORM 기능을 수행하기 위한 표준 API가 JPA
- JPA라는 표준 명세서를 따라 구현된 것이 Hibernate
- JPA라는 표준 명세서에는 엔티티 매니저와 영속성 컨텍스트가 정의되어있음
    
    ⇒ Hibernate는 JPA라는 표준 명세서 써있는 기능(엔티티 매니저와 영속성 컨텍스트 등) 사용 가능